<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/qlPersonalBlog.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/qlPersonalBlog.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/qlPersonalBlog.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/qlPersonalBlog.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/qlPersonalBlog.github.io/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/qlPersonalBlog.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/qlPersonalBlog.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="判断 js 类型的方式1234567891011121314&#x2F;&#x2F;定义不同类型变量var a &#x3D; &#39;intamsp&#39;;    var b &#x3D; 2223;	var c &#x3D; [1,2,3];	var d &#x3D; new Date();	var e &#x3D; function ()&amp;#123;		alert(111)	&amp;#125;">
<meta property="og:type" content="article">
<meta property="og:title" content="js">
<meta property="og:url" content="http://yoursite.com/2020/04/15/js/index.html">
<meta property="og:site_name" content="Qiris&#39;s blog">
<meta property="og:description" content="判断 js 类型的方式1234567891011121314&#x2F;&#x2F;定义不同类型变量var a &#x3D; &#39;intamsp&#39;;    var b &#x3D; 2223;	var c &#x3D; [1,2,3];	var d &#x3D; new Date();	var e &#x3D; function ()&amp;#123;		alert(111)	&amp;#125;">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/1490251-48851bf37a08259d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/556/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/1490251-e7476a8697e97aab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/567/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/1490251-0cac772635e8a128.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/518/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/1490251-293b8fe01cf2ef5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/609/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/1490251-3089c135df71c956.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/604/format/webp">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1566904/201901/1566904-20190104144654692-1100182048.jpg">
<meta property="og:image" content="https://images0.cnblogs.com/blog/138012/201409/241708372951952.png">
<meta property="article:published_time" content="2020-04-15T07:07:20.940Z">
<meta property="article:modified_time" content="2020-04-15T07:13:32.581Z">
<meta property="article:author" content="Qiris">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/1490251-48851bf37a08259d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/556/format/webp">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/qlPersonalBlog.github.io/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/04/15/js/"/>





  <title>js | Qiris's blog</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/qlPersonalBlog.github.io/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Qiris's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/qlPersonalBlog.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-csscaseinterview">
          <a href="/qlPersonalBlog.github.io/css" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-css3"></i> <br />
            
            css题库
          </a>
        </li>
      
        
        <li class="menu-item menu-item-jscaseinterview">
          <a href="/qlPersonalBlog.github.io/js" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-instagram"></i> <br />
            
            javascript题库
          </a>
        </li>
      
        
        <li class="menu-item menu-item-htmlcaseinterview">
          <a href="/qlPersonalBlog.github.io/html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-html5"></i> <br />
            
            html题库
          </a>
        </li>
      
        
        <li class="menu-item menu-item-vuecaseinterview">
          <a href="/qlPersonalBlog.github.io/vue" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-fire"></i> <br />
            
            vue题库
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/qlPersonalBlog.github.io/2020/04/15/js/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qiris">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/qlPersonalBlog.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qiris's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">js</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-15T15:07:20+08:00">
                2020-04-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h6 id="判断-js-类型的方式"><a href="#判断-js-类型的方式" class="headerlink" title="判断 js 类型的方式"></a>判断 js 类型的方式</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;定义不同类型变量</span><br><span class="line">var a &#x3D; &#39;intamsp&#39;;</span><br><span class="line">    var b &#x3D; 2223;</span><br><span class="line">	var c &#x3D; [1,2,3];</span><br><span class="line">	var d &#x3D; new Date();</span><br><span class="line">	var e &#x3D; function ()&#123;</span><br><span class="line">		alert(111)</span><br><span class="line">	&#125;;</span><br><span class="line">	var f &#x3D; function ()&#123;</span><br><span class="line">    	this.name &#x3D; &#39;222&#39;</span><br><span class="line">	&#125;;</span><br><span class="line">	var g &#x3D; true;</span><br><span class="line">	var h;</span><br><span class="line">	var i &#x3D; null</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.typeof</span><br><span class="line">	console.log(typeof a)  &#x2F;&#x2F;string</span><br><span class="line">	console.log(typeof b)	&#x2F;&#x2F;number</span><br><span class="line">	console.log(typeof c)	&#x2F;&#x2F;object</span><br><span class="line">	console.log(typeof d)	&#x2F;&#x2F;object</span><br><span class="line">	console.log(typeof e)	&#x2F;&#x2F;function</span><br><span class="line">	console.log(typeof f)	&#x2F;&#x2F;function</span><br><span class="line">	console.log(typeof g)	&#x2F;&#x2F;boolean</span><br><span class="line">	console.log(typeof h)	&#x2F;&#x2F;undefined</span><br><span class="line">	console.log(typeof i)	&#x2F;&#x2F;object</span><br><span class="line">	console.log(typeof a &#x3D;&#x3D;&#x3D; &#39;string&#39;)	&#x2F;&#x2F;true</span><br><span class="line">	console.log(typeof c &#x3D;&#x3D;&#x3D;&#39;object&#39;) &#x2F;&#x2F;true</span><br><span class="line">	console.log(typeof e &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#x2F;&#x2F;true</span><br><span class="line">	注意：typeof返回的都是字符串形式,可以判断function的类型,在判断除Object类型的对象时比较方便;null类型为object;数组和对象均为object</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2.instanceof:判断已知对象类型的方法</span><br><span class="line">    var str &#x3D; new String()</span><br><span class="line">	console.log(a instanceof String) &#x2F;&#x2F;false</span><br><span class="line">	console.log(c instanceof Array) &#x2F;&#x2F;false</span><br><span class="line">	console.log(d instanceof Date)  &#x2F;&#x2F;false</span><br><span class="line">	console.log(f instanceof Function)	&#x2F;&#x2F;false</span><br><span class="line">	console.log(str instanceof String)  &#x2F;&#x2F;false</span><br><span class="line">	注意:如果只是单纯将一个字符串赋值给变量,虽然类型为string,但并不是String对象，没有创建实例，所以只有new一个String实例,则instanceof属于String,但是typeof在原型链中找最高级,new属于对象,所以typeof为object</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3.Object.prototype.toString.call():常用于判断浏览器内置对象,对于所有基本的数据类型都能进行判断,即使是null和undefined</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.Array.isArray():用于判断是否为数组</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5.jquery.type():功能与上相同</span><br></pre></td></tr></table></figure>
<h6 id="ES5-和-ES6-分别几种方式声明变量"><a href="#ES5-和-ES6-分别几种方式声明变量" class="headerlink" title="ES5 和 ES6 分别几种方式声明变量"></a>ES5 和 ES6 分别几种方式声明变量</h6><ul>
<li>es5:var 和 function</li>
<li>es6: 增加四种,let const class import<h6 id="闭包的概念？优缺点？"><a href="#闭包的概念？优缺点？" class="headerlink" title="闭包的概念？优缺点？"></a>闭包的概念？优缺点？</h6></li>
<li>闭包的概念：闭包就是能读取其他函数内部变量的函数</li>
<li>闭包的优点：避免全局变量的污染；希望一个变量长期存储在内存中(缓存变量)</li>
<li>闭包的缺点：内存泄露(消耗)；常驻内存,增加内存使用量<h6 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h6></li>
<li>浅拷贝:仅仅是指向被复制的内存地址,如果原地址中的对象被改变 ,那么浅拷贝出来的对象也会相应改变</li>
<li>深拷贝的实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [1,3,&#123;</span><br><span class="line">    username:&#39;kobe&#39;</span><br><span class="line">&#125;]</span><br><span class="line">let arr2 &#x3D; JSON.parse(JSON.stringify(arr))</span><br><span class="line">arr2[2].username &#x3D; &#39;newName&#39;</span><br><span class="line">console.log(arr,arr2)</span><br><span class="line">原理:用JSON.stringify将对象转成JSON字符串,再用JSON.prase()把字符串解析成对象,这样生成了新的对象,对象会开辟新的栈,实现深拷贝,但是不能处理函数</span><br></pre></td></tr></table></figure>
<h6 id="数组去重的方法"><a href="#数组去重的方法" class="headerlink" title="数组去重的方法"></a>数组去重的方法</h6></li>
<li>for循环嵌套for使用splice()去重 正向遍历循环</li>
<li>for循环嵌套for使用splice()去重 逆向遍历循环</li>
<li>includes去重 返回新数组</li>
<li>利用对象的属性key唯一的特性去重</li>
<li>利用set数据结构的特性(set集合里所有的元素都是唯一的)</li>
<li>利用map数据结构的特性去重</li>
<li>利用sort()去重(不太建议)</li>
<li>reduce()数组去重  <h6 id="js的typeof返回哪些数据类型"><a href="#js的typeof返回哪些数据类型" class="headerlink" title="js的typeof返回哪些数据类型"></a>js的typeof返回哪些数据类型</h6></li>
<li>string boolean object number undefined function<h6 id="列举3中强制类型转换和2中隐式类型转换"><a href="#列举3中强制类型转换和2中隐式类型转换" class="headerlink" title="列举3中强制类型转换和2中隐式类型转换"></a>列举3中强制类型转换和2中隐式类型转换</h6></li>
<li>强制:praseInt praseFoat number</li>
<li>隐式:<h6 id="split-join-的区别"><a href="#split-join-的区别" class="headerlink" title="split() join()的区别"></a>split() join()的区别</h6></li>
<li>前者是将字符串切割成数组的形式,后者是将数组转换为字符串<h6 id="数组方法pop-push-unshift-shift"><a href="#数组方法pop-push-unshift-shift" class="headerlink" title="数组方法pop() push() unshift() shift()"></a>数组方法pop() push() unshift() shift()</h6></li>
<li>push()尾部添加 pop()尾部删除 unshift()头部添加 shift()头部删除<h6 id="ie和标准下有哪些兼容性的写法"><a href="#ie和标准下有哪些兼容性的写法" class="headerlink" title="ie和标准下有哪些兼容性的写法"></a>ie和标准下有哪些兼容性的写法</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var ev &#x3D; ev || window.event</span><br><span class="line">document.documentElement.clientWidth || document.body.clientWidth</span><br><span class="line">Var target &#x3D; ev.srcElement||ev.target</span><br></pre></td></tr></table></figure>
<h6 id="ajax请求的时候-get和post方式的区别"><a href="#ajax请求的时候-get和post方式的区别" class="headerlink" title="ajax请求的时候 get和post方式的区别"></a>ajax请求的时候 get和post方式的区别</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">get和post都是向服务器发送一种请求，只是发送机制不同 </span><br><span class="line">1 GET请求会将参数跟在URL后进行传递，而POST请求则是作为HTTP消息的实体内容发送给WEB服务器。 </span><br><span class="line">2.首先是”GET方式提交的数据最多只能是1024字节”，Post传输的数据量大，可以达到2M。 </span><br><span class="line">3.get方式请求数据会被浏览器缓存起来，因此其他人就可以从浏览器的历史记录中读取到这些数据，例如账号密码等。在某种情况下，get方式会带来严重的安全问题。而post方式相对来说就可以避免这些问题。 </span><br><span class="line">4.Post请求必须设置Content-Type值为application&#x2F;x-form-www-urlencoded； </span><br><span class="line">5.发送请求时,因为Get请求的参数都在url里,所以send函数发送的参数为null,而Post请求在使用send方法时,却需赋予其参数；</span><br></pre></td></tr></table></figure>
<h6 id="call-和apply-的作用与区别"><a href="#call-和apply-的作用与区别" class="headerlink" title="call()和apply()的作用与区别"></a>call()和apply()的作用与区别</h6></li>
<li>作用:改变this指向</li>
<li>区别:call()第一个参数是this值没有变化,变化的是其余参数都直接传递给函数,传递给函数的参数必须逐个列举出来;apply()传递给函数的是参数数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function add(c, d)&#123; </span><br><span class="line">    return this.a + this.b + c + d; </span><br><span class="line">&#125; </span><br><span class="line">var o &#x3D; &#123;a:1, b:3&#125;; </span><br><span class="line">add.call(o, 5, 7); &#x2F;&#x2F; 1 + 3 + 5 + 7 &#x3D; 16 </span><br><span class="line">add.apply(o, [10, 20]); &#x2F;&#x2F; 1 + 3 + 10 + 20 &#x3D; 34</span><br></pre></td></tr></table></figure>
<h6 id="ajax请求时-如何解析json数据"><a href="#ajax请求时-如何解析json数据" class="headerlink" title="ajax请求时,如何解析json数据"></a>ajax请求时,如何解析json数据</h6></li>
<li>使用JSON.prase</li>
</ul>
<h6 id="事件委托是什么"><a href="#事件委托是什么" class="headerlink" title="事件委托是什么"></a>事件委托是什么</h6><ul>
<li>利用事件冒泡的原理,让自己所触发的事件,让他的父元素代替执行</li>
</ul>
<h6 id="如何组织事件冒泡"><a href="#如何组织事件冒泡" class="headerlink" title="如何组织事件冒泡"></a>如何组织事件冒泡</h6><ul>
<li>ie: ev.cancelBubble = true; 非ie ev.stopPropagation()</li>
</ul>
<h6 id="如何阻止默认事件"><a href="#如何阻止默认事件" class="headerlink" title="如何阻止默认事件"></a>如何阻止默认事件</h6><ul>
<li>return false ; ev.preventDefalut</li>
</ul>
<h6 id="添加-删除-替换-插入到某个节点的方法"><a href="#添加-删除-替换-插入到某个节点的方法" class="headerlink" title="添加 删除 替换 插入到某个节点的方法"></a>添加 删除 替换 插入到某个节点的方法</h6><ul>
<li>创建新节点<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">createElement() &#x2F;&#x2F;创建一个具体的元素</span><br><span class="line">createTextNode() &#x2F;&#x2F;创建一个文本节点</span><br></pre></td></tr></table></figure></li>
<li>添加 移除 替换 插入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">appendChild() &#x2F;&#x2F;添加</span><br><span class="line">removeChild() &#x2F;&#x2F;移除</span><br><span class="line">replaceChild() &#x2F;&#x2F;替换</span><br><span class="line">insertBefore() &#x2F;&#x2F;插入</span><br></pre></td></tr></table></figure></li>
<li>查找<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getElementByTagName() &#x2F;&#x2F;通过标签名称</span><br><span class="line">getElementByName() &#x2F;&#x2F;通过元素的name属性的值</span><br><span class="line">getElementById() &#x2F;&#x2F;通过元素id,唯一性</span><br></pre></td></tr></table></figure>
<h6 id="结束jsonp的原理-以及为什么不是真正的ajax"><a href="#结束jsonp的原理-以及为什么不是真正的ajax" class="headerlink" title="结束jsonp的原理,以及为什么不是真正的ajax"></a>结束jsonp的原理,以及为什么不是真正的ajax</h6></li>
<li>动态创建script标签,回调函数</li>
<li>ajax是页面无刷新请求数据操作</li>
</ul>
<h6 id="doucument-load-和-doucument-ready的区别"><a href="#doucument-load-和-doucument-ready的区别" class="headerlink" title="doucument load 和 doucument ready的区别"></a>doucument load 和 doucument ready的区别</h6><ul>
<li>前者是在结构 样式 外部js 图片加载完才执行js</li>
<li>后者是jq在dom树创建完成就执行的方法</li>
</ul>
<h6 id="和-不同"><a href="#和-不同" class="headerlink" title="= =和===不同"></a>= =和===不同</h6><ul>
<li>前者会自动转换类型,再判断是否相等</li>
<li>后者不会自动类型转换,直接去比较</li>
</ul>
<h6 id="函数声明与函数表达式的区别"><a href="#函数声明与函数表达式的区别" class="headerlink" title="函数声明与函数表达式的区别"></a>函数声明与函数表达式的区别</h6><ul>
<li>js解析器在向执行环境中加载数据时,率先读取函数声明,并使其在执行任何代码之前可用,而函数表达式是必须等到解析器执行到它所在的代码航才会真正被解析执行</li>
</ul>
<h6 id="对作用于上下文和this的理解"><a href="#对作用于上下文和this的理解" class="headerlink" title="对作用于上下文和this的理解"></a>对作用于上下文和this的理解</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var User &#x3D; &#123;</span><br><span class="line"> count: 1,</span><br><span class="line"> getCount: function() &#123;</span><br><span class="line">  return this.count;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(User.getCount()); &#x2F;&#x2F; what?</span><br><span class="line">var func &#x3D; User.getCount;</span><br><span class="line">console.log(func()); &#x2F;&#x2F; what?</span><br><span class="line">问两处console输出什么？为什么？</span><br><span class="line">答案:是1和undefined。</span><br><span class="line">　　func是在window的上下文中被执行的，所以不会访问到count属性。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(var i &#x3D; 1; i &lt;&#x3D; 3; i++)&#123;  &#x2F;&#x2F;建议使用let 可正常输出i的值</span><br><span class="line">  setTimeout(function()&#123;</span><br><span class="line">      console.log(i);   </span><br><span class="line">  &#125;,0); </span><br><span class="line">&#125;;</span><br><span class="line">答案：4 4 4。</span><br><span class="line">原因：Javascript事件处理器在线程空闲之前不会运行。</span><br></pre></td></tr></table></figure>
<h6 id="javascript的同源策略"><a href="#javascript的同源策略" class="headerlink" title="javascript的同源策略"></a>javascript的同源策略</h6><ul>
<li>同源策略是一个很重要的安全理念,在保证数据的安全性方面有很重要的意义,一段脚本只能读取来自于同一来源的窗口和文档的属性,这里的同一来源指的是协议、域名、端口号组合</li>
</ul>
<h6 id="最快捷的数组求最大值"><a href="#最快捷的数组求最大值" class="headerlink" title="最快捷的数组求最大值"></a>最快捷的数组求最大值</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [ 1,5,1,7,5,9];</span><br><span class="line">Math.max(...arr)  &#x2F;&#x2F; 9</span><br></pre></td></tr></table></figure>

<h6 id="简洁的数组去重"><a href="#简洁的数组去重" class="headerlink" title="简洁的数组去重"></a>简洁的数组去重</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...new Set([2,12,12,1,2,16,13,&#39;12&#39;])]</span><br></pre></td></tr></table></figure>

<h6 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h6><ul>
<li>升序<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var numberArray &#x3D; [3,6,2,4,1,5];</span><br><span class="line">numberArray.sort(function(a,b)&#123;  </span><br><span class="line">   return a-b;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(numberArray);</span><br></pre></td></tr></table></figure>
<h6 id="找字符串中出现次数最多的字符"><a href="#找字符串中出现次数最多的字符" class="headerlink" title="找字符串中出现次数最多的字符"></a>找字符串中出现次数最多的字符</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var str &#x3D; &quot;nininihaoa&quot;;</span><br><span class="line">    var o &#x3D; &#123;&#125;;</span><br><span class="line">    for (var i &#x3D; 0, length &#x3D; str.length; i &lt; length; i++) &#123;</span><br><span class="line">        var char &#x3D; str.charAt(i);</span><br><span class="line">        if (o[char]) &#123;</span><br><span class="line">            o[char]++;  &#x2F;&#x2F;次数加1</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            o[char] &#x3D; 1;    &#x2F;&#x2F;若第一次出现，次数记为1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(o);   &#x2F;&#x2F;输出的是完整的对象，记录着每一个字符及其出现的次数</span><br><span class="line">    &#x2F;&#x2F;遍历对象，找到出现次数最多的字符的次数</span><br><span class="line">    var max &#x3D; 0;</span><br><span class="line">    for (var key in o) &#123;</span><br><span class="line">        if (max &lt; o[key]) &#123;</span><br><span class="line">            max &#x3D; o[key];   &#x2F;&#x2F;max始终储存次数最大的那个</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (var key in o) &#123;</span><br><span class="line">        if (o[key] &#x3D;&#x3D; max) &#123;</span><br><span class="line">            &#x2F;&#x2F;console.log(key);</span><br><span class="line">            console.log(&quot;最多的字符是&quot; + key);</span><br><span class="line">            console.log(&quot;出现的次数是&quot; + max);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h6 id="js的事件流模型"><a href="#js的事件流模型" class="headerlink" title="js的事件流模型"></a>js的事件流模型</h6></li>
<li>事件冒泡:事件开始由最具体的元素接收,然后逐级向上传播</li>
<li>事件捕捉:事件由最不具体的节点先接收,然后逐级向下一直到最具体的</li>
<li>dom事件流:事件捕捉,目标阶段,事件冒泡<h6 id="判断字符串以字母开头-后面可以是数字-下划线-字母-长度为6-30"><a href="#判断字符串以字母开头-后面可以是数字-下划线-字母-长度为6-30" class="headerlink" title="判断字符串以字母开头,后面可以是数字,下划线,字母,长度为6-30"></a>判断字符串以字母开头,后面可以是数字,下划线,字母,长度为6-30</h6></li>
<li>var reg = /^[a-zA-Z]\W{5,29}$/<h6 id="js的2中变量范围有什么不同"><a href="#js的2中变量范围有什么不同" class="headerlink" title="js的2中变量范围有什么不同"></a>js的2中变量范围有什么不同</h6></li>
<li>全局变量:当前页面内有效</li>
<li>局部变量:函数方法内有效<h6 id="原型-原型链-构造函数-实例-继承"><a href="#原型-原型链-构造函数-实例-继承" class="headerlink" title="原型/原型链/构造函数/实例/继承"></a>原型/原型链/构造函数/实例/继承</h6></li>
<li><strong>构造函数创建对象</strong>:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var person &#x3D; new Person();</span><br><span class="line">person.name &#x3D; &#39;Kevin&#39;;</span><br><span class="line">console.log(person.name) &#x2F;&#x2F; Kevin</span><br></pre></td></tr></table></figure></li>
</ul>
<p>1.prototype:每个函数都有一个prototype属性,每一个js对象在创建的时候就会与之关联另一个对象,这个对象就是常说的原型,每一个对象都会从原型继承属性<br><img src="https://upload-images.jianshu.io/upload_images/1490251-48851bf37a08259d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/556/format/webp" alt="image"><br>2.proto:每一个js对象(除了null)都具有的属性,该属性指向对象的原型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var person &#x3D; new Person();</span><br><span class="line">console.log(person.__proto__ &#x3D;&#x3D;&#x3D; Person.prototype); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/1490251-e7476a8697e97aab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/567/format/webp" alt="image"><br>3.constructor:每个原型都有的属性,指向关联的构造函数,实例原型指向构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(Person &#x3D;&#x3D;&#x3D; Person.prototype.constructor); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/1490251-0cac772635e8a128.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/518/format/webp" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person &#x3D; new Person();</span><br><span class="line"></span><br><span class="line">console.log(person.__proto__ &#x3D;&#x3D; Person.prototype) &#x2F;&#x2F; true</span><br><span class="line">console.log(Person.prototype.constructor &#x3D;&#x3D; Person) &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; 顺便学习一个ES5的方法,可以获得对象的原型</span><br><span class="line">console.log(Object.getPrototypeOf(person) &#x3D;&#x3D;&#x3D; Person.prototype) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>实例与原型</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name &#x3D; &#39;Kevin&#39;;</span><br><span class="line"></span><br><span class="line">var person &#x3D; new Person();</span><br><span class="line"></span><br><span class="line">person.name &#x3D; &#39;Daisy&#39;;</span><br><span class="line">console.log(person.name) &#x2F;&#x2F; Daisy</span><br><span class="line"></span><br><span class="line">delete person.name;</span><br><span class="line">console.log(person.name) &#x2F;&#x2F; Kevin</span><br></pre></td></tr></table></figure>
以上给实例对象person添加了name属性,当打印该属性时获得实例赋值的Daisy,但是当删除了person的name属性时,读取person.name,从person对象中找不到name属性,就会从person的原型,也就是person.proto,也就是Person.prototype中查找,结果为Kevin</li>
<li><strong>原型与原型</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; new Object();</span><br><span class="line">obj.name &#x3D; &#39;Kevin&#39;</span><br><span class="line">console.log(obj.name) &#x2F;&#x2F; Kevin</span><br></pre></td></tr></table></figure>
<img src="https://upload-images.jianshu.io/upload_images/1490251-293b8fe01cf2ef5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/609/format/webp" alt="image"></li>
<li><strong>原型链</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.protope._proto_ &#x3D;&#x3D;&#x3D; null) &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>
<img src="https://upload-images.jianshu.io/upload_images/1490251-3089c135df71c956.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/604/format/webp" alt="image"><br>js默认不会复制对象的属性,而只是在两个对象之间创建一个关联,这样一个对象可以用过委托访问另一个对象的属性和函数</li>
<li>对象都有_proto_属性,这个是隐式的原型,该隐式原型指向构造该对象的构造函数的原型,而函数除了这个属性,还有prototype属性,这个属性是一个指针,指向一个包含所有实例共享的属性和方法的对象(原型对象),该对象的constructor属性指向构造函数</li>
<li><strong>面试题1</strong>:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var F &#x3D; function () &#123;&#125;</span><br><span class="line">Object.prototype.a &#x3D; function () &#123;&#125;</span><br><span class="line">Function.prototype.b &#x3D; function () &#123;&#125;</span><br><span class="line"></span><br><span class="line">var f &#x3D; new F()</span><br><span class="line">&#x2F;&#x2F; 请问f有方法a  方法b吗</span><br></pre></td></tr></table></figure>
f的_proto_指向F.prototype,F.prototype._proto_指向Object.prototype,所以f可以获取到a方法,由于f的原型链上没有经过Function.prototype,所以获取不到b方法;由于构造函数F是由Function new出来的,所以F._proto_指向Function.prototype,所以F函数可以获取到b方法</li>
<li><strong>面试题2</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;</span><br><span class="line"></span><br><span class="line">let p1 &#x3D; new Person()</span><br><span class="line">let p2 &#x3D; new Person()</span><br><span class="line">let obj &#x3D; &#123;&#125;</span><br></pre></td></tr></table></figure>
p1:      <strong>proto</strong> :  Person.prototype       </li>
</ul>
<p>　　p2:      <strong>proto</strong> :  Person.prototype </p>
<p>　　Person  :         <strong>proto</strong>： Function.prototype，    prototype： Person.prototype</p>
<p>　　Person.prototype ：         <strong>proto</strong> ： Object.prototype ，  constructor： Person</p>
<p>　　Function：       <strong>proto</strong> ： Function.prototype，   prototype： Function.prototype</p>
<p>　　Function.Prototype：     <strong>proto</strong> ：  Object.prototype ，   constructor：  Function</p>
<p>　　obj：    <strong>proto</strong> ： Object.prototype</p>
<p>　　Object：   <strong>proto</strong> ： Function.prototype  ，   prototype：  Object.prototype</p>
<p>　　Object.prototype：    <strong>proto</strong> ：  null  ，   constructor  ：  Object
　　</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1，Function.__proto__    &#x3D;&#x3D;&#x3D;     Function.prototype</span><br><span class="line">  Function.prototype是引擎创造出来的对象，一开始就有了，又因为其他的构造函数都可以通过原型链找到Function.prototype，Function本身也是一个构造函数，为了不产生混乱，就将这两个联系到一起了。</span><br><span class="line"></span><br><span class="line">2，Object.__proto__  &#x3D;&#x3D;&#x3D; Function.prototype</span><br><span class="line">　Object是对象的构造函数，那么它也是一个函数，当然它的__proto__也是指向Function.prototype</span><br></pre></td></tr></table></figure>
<p><img src="https://img2018.cnblogs.com/blog/1566904/201901/1566904-20190104144654692-1100182048.jpg" alt="image"></p>
<ul>
<li><strong>面试题3</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function A() &#123;&#125;</span><br><span class="line">function B(a) &#123;</span><br><span class="line">    this.a &#x3D; a;</span><br><span class="line">&#125;</span><br><span class="line">function C(a) &#123;</span><br><span class="line">    if (a) &#123;</span><br><span class="line">        this.a &#x3D; a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.a &#x3D; 1;</span><br><span class="line">B.prototype.a &#x3D; 1;</span><br><span class="line">C.prototype.a &#x3D; 1;</span><br><span class="line"></span><br><span class="line">console.log(new A().a);</span><br><span class="line">console.log(new B().a);</span><br><span class="line">console.log(new C(2).a);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>1.拆解:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;新建一个构造函数A</span><br><span class="line">function A() &#123;&#125;</span><br><span class="line">&#x2F;&#x2F;新建一个构造函数B，并添加一个自有属性a，属性a的值取决于传入的参数</span><br><span class="line">function B(a) &#123;</span><br><span class="line">    this.a &#x3D; a;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;新建一个构造函数C，如果有参数，则添加自有属性a，属性a的值为传入的参数值，</span><br><span class="line">&#x2F;&#x2F;如果没有传入参数，则构造函数C没有自有属性</span><br><span class="line">function C(a) &#123;</span><br><span class="line">    if (a) &#123;</span><br><span class="line">        this.a &#x3D; a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;在A的原型对象上添加一个属性a，属性a的值是1，(两个同理)</span><br><span class="line">A.prototype.a &#x3D; 1;</span><br><span class="line">B.prototype.a &#x3D; 1;</span><br><span class="line">C.prototype.a &#x3D; 1;</span><br></pre></td></tr></table></figure>
<p>2.求A的实例下属性a的值,即new A().a:构造函数function A(){}没有自身属性,顺着到原型链查找到原型对象A.prototype.a = 1<br>3.求B的实例下属性a的值,即new B().a:由于创建B实例的时候没有传入参数所以最后输出undefined,因为undefined也是值,所以会停止在原型链上查找值<br>4.求C的实例下属性a的值,即new C(2).a:同上理解输出自身属性2</p>
<h6 id="实现继承的几种方式"><a href="#实现继承的几种方式" class="headerlink" title="实现继承的几种方式"></a>实现继承的几种方式</h6><ul>
<li><strong>原型链继承</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 原型链继承</span><br><span class="line">        function Person()&#123;</span><br><span class="line">            this.name &#x3D; &#39;xiaopao&#39;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Person.prototype.getName &#x3D; function()&#123;</span><br><span class="line">            console.log(this.name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function Child()&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Child.prototype &#x3D; new Person();</span><br><span class="line">        var child1 &#x3D; new Child();</span><br><span class="line">        child1.getName(); &#x2F;&#x2F; xiaopao</span><br></pre></td></tr></table></figure>
缺点:引用类型的属性被所有实例共享;在创建Child的实例时不能向Person传参<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">            this.name &#x3D; &#39;xiaopao&#39;;</span><br><span class="line">            this.colors &#x3D; [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Person.prototype.getName &#x3D; function()&#123;</span><br><span class="line">            console.log(this.name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function Child()&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Child.prototype &#x3D; new Person();</span><br><span class="line">        var child1 &#x3D; new Child();</span><br><span class="line">        var child2 &#x3D; new Child();</span><br><span class="line">        child1.colors.push(&#39;yellow&#39;);</span><br><span class="line">        console.log(child1.colors);  &#x2F;&#x2F; [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;,&quot;yellow&quot;]</span><br><span class="line">        console.log(child2.colors);  &#x2F;&#x2F; [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;,&quot;yellow&quot;]</span><br></pre></td></tr></table></figure></li>
<li><strong>借用构造函数(经典继承)</strong>:复用父类构造函数内的属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 借用构造函数继承（经典继承）</span><br><span class="line">        function Person()&#123;</span><br><span class="line">            this.name &#x3D; &#39;xiaopao&#39;;</span><br><span class="line">            this.colors &#x3D; [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Person.prototype.getName &#x3D; function()&#123;</span><br><span class="line">            console.log(this.name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function Child()&#123;</span><br><span class="line">            Person.call(this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var child1 &#x3D; new Child();</span><br><span class="line">        var child2 &#x3D; new Child();</span><br><span class="line">        child1.colors.push(&#39;yellow&#39;);</span><br><span class="line">        console.log(child1.name);</span><br><span class="line">        console.log(child1.colors); &#x2F;&#x2F; [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;]</span><br><span class="line">        console.log(child2.colors); &#x2F;&#x2F; [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</span><br></pre></td></tr></table></figure>
优点:避免了引用类型的属性被所有实例共享;可以在Child中向Parent传参<br>缺点:只是子类的实例,不是父类的实例;方法都在构造函数中定义,每次创建实例都会创建一遍方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 借用构造函数继承， 向Parent传参</span><br><span class="line">  function Person(name)&#123;</span><br><span class="line">            this.name &#x3D; name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Person.prototype.getName &#x3D; function()&#123;</span><br><span class="line">            console.log(this.name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function Child(name)&#123;</span><br><span class="line">            Person.call(this,name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var child1 &#x3D; new Child(&#39;xiaopao&#39;);</span><br><span class="line">        var child2 &#x3D; new Child(&#39;lulu&#39;);</span><br><span class="line">        console.log(child1.name); &#x2F;&#x2F; xiaopao</span><br><span class="line">        console.log(child2.name); &#x2F;&#x2F; lulu</span><br><span class="line">        console.log(child1 instanceof Person); &#x2F;&#x2F; false   不能识别是Person的实例</span><br></pre></td></tr></table></figure></li>
<li><strong>组合继承</strong>:组合原型链继承和借用构造函数继承,使用原型链实现对原型方法的继承,而通过借用构造函数来实现对实例属性的继承<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function Parent(name)&#123;</span><br><span class="line">            this.name &#x3D; name;</span><br><span class="line">            this.colors &#x3D; [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Parent.prototype.getName &#x3D; function()&#123;</span><br><span class="line">            console.log(this.name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function Child(name,age)&#123;</span><br><span class="line">            Parent.call(this,name);&#x2F;&#x2F; 第二次调用 Parent()</span><br><span class="line">            this.age &#x3D; age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Child.prototype &#x3D; new Parent(); &#x2F;&#x2F; 第一次调用 Parent()</span><br><span class="line"></span><br><span class="line">        var child1 &#x3D; new Child(&#39;xiaopao&#39;,18);</span><br><span class="line">        var child2 &#x3D; new Child(&#39;lulu&#39;,19);</span><br><span class="line">        child1.getName(); &#x2F;&#x2F; xiaopao</span><br><span class="line">        child2.getName(); &#x2F;&#x2F; lulu</span><br><span class="line">        console.log(child1.age); &#x2F;&#x2F; 18</span><br><span class="line">        console.log(child2.age); &#x2F;&#x2F; 19</span><br><span class="line">        child1.colors.push(&#39;yellow&#39;);</span><br><span class="line">        console.log(child1.colors);  &#x2F;&#x2F; [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;]</span><br><span class="line">        console.log(child2.colors); &#x2F;&#x2F; [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</span><br><span class="line">        console.log(child1 instanceof Child); &#x2F;&#x2F; true</span><br><span class="line">        console.log(child1 instanceof Parent); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
优点:融合原型链继承和构造函数的优点,是最常见的继承模式<br>缺点:调用了两次父类构造函数(一是在创建子类型原型的时候,二是在子类型构造函数内部)</li>
<li><strong>原式型继承</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; 原型式继承</span><br><span class="line">function CreateObj(o)&#123;</span><br><span class="line">            function F()&#123;&#125;</span><br><span class="line">            F.prototype &#x3D; o;</span><br><span class="line">            console.log(o.__proto__ &#x3D;&#x3D;&#x3D; Object.prototype);</span><br><span class="line">            console.log(F.prototype.constructor &#x3D;&#x3D;&#x3D; Object); &#x2F;&#x2F; true</span><br><span class="line">            return new F();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var person &#x3D; &#123;</span><br><span class="line">            name: &#39;xiaopao&#39;,</span><br><span class="line">            friend: [&#39;daisy&#39;,&#39;kelly&#39;]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var person1 &#x3D; CreateObj(person);</span><br><span class="line">        &#x2F;&#x2F; var person2 &#x3D; CreateObj(person);</span><br><span class="line"></span><br><span class="line">        person1.name &#x3D; &#39;person1&#39;;</span><br><span class="line">        &#x2F;&#x2F; console.log(person2.name); &#x2F;&#x2F; xiaopao</span><br><span class="line">        person1.friend.push(&#39;taylor&#39;);</span><br><span class="line">        &#x2F;&#x2F; console.log(person2.friend); &#x2F;&#x2F; [&quot;daisy&quot;, &quot;kelly&quot;, &quot;taylor&quot;]</span><br><span class="line">        &#x2F;&#x2F; console.log(person); &#x2F;&#x2F; &#123;name: &quot;xiaopao&quot;, friend: Array(3)&#125;</span><br><span class="line">        person1.friend &#x3D; [&#39;lulu&#39;];</span><br><span class="line">        &#x2F;&#x2F; console.log(person1.friend); &#x2F;&#x2F; [&quot;lulu&quot;]</span><br><span class="line">        &#x2F;&#x2F; console.log(person.friend); &#x2F;&#x2F;  [&quot;daisy&quot;, &quot;kelly&quot;, &quot;taylor&quot;]</span><br><span class="line">        &#x2F;&#x2F; 注意： 这里修改了person1.name的值，person2.name的值并未改变，并不是因为person1和person2有独立的name值，而是person1.name&#x3D;&#39;person1&#39;是给person1添加了name值，并非修改了原型上的name值</span><br><span class="line">        &#x2F;&#x2F; 因为我们找对象上的属性时，总是先找实例上对象，没有找到的话再去原型对象上的属性。实例对象和原型对象上如果有同名属性，总是先取实例对象上的值</span><br></pre></td></tr></table></figure>
缺点:包含引用类型的属性值始终会共享相应的值</li>
<li><strong>寄生式继承</strong>:创建一个仅用于封装继承过程的函数,该函数在内部以某种形式来做增强对象,最后返回对象,可以理解为在原型式继承的基础上新增一些函数或属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 寄生式继承  可以理解为在原型式继承的基础上增加一些函数或属性</span><br><span class="line">var ob &#x3D; &#123;</span><br><span class="line">    name: &#39;xiaopao&#39;,</span><br><span class="line">    friends: [&#39;lulu&#39;,&#39;huahua&#39;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function CreateObj(o)&#123;</span><br><span class="line">    function F()&#123;&#125;;  &#x2F;&#x2F; 创建一个构造函数F</span><br><span class="line">    F.prototype &#x3D; o;</span><br><span class="line">    return new F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 上面CreateObj函数 在ECMAScript5 有了一新的规范写法，Object.create(ob) 效果是一样的 , 看下面代码</span><br><span class="line">var ob1 &#x3D; CreateObj(ob);</span><br><span class="line">var ob2 &#x3D; Object.create(ob);</span><br><span class="line">console.log(ob1.name); &#x2F;&#x2F; xiaopao</span><br><span class="line">console.log(ob2.name); &#x2F;&#x2F; xiaopao</span><br><span class="line"></span><br><span class="line">function CreateOb(o)&#123;</span><br><span class="line">    var newob &#x3D; CreateObj(o); &#x2F;&#x2F; 创建对象 或者用 var newob &#x3D; Object.create(ob)</span><br><span class="line">    newob.sayName &#x3D; function()&#123; &#x2F;&#x2F; 增强对象</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">    return newob; &#x2F;&#x2F; 指定对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1 &#x3D; CreateOb(ob);</span><br><span class="line">p1.sayName(); &#x2F;&#x2F; xiaopao</span><br></pre></td></tr></table></figure>
缺点:跟借用构造函数一样,每次创建对象都会创建一遍方法</li>
<li><strong>寄生组合式继承</strong>:子类构造函数复制父类的自身属性和方法,子类原型只接收父类的原型属性和方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 寄生组合式继承</span><br><span class="line">function Parent(name)&#123;</span><br><span class="line">            this.name &#x3D; name;</span><br><span class="line">            this.colors &#x3D; [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Parent.prototype.sayName &#x3D; function()&#123;</span><br><span class="line">            console.log(this.name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function Child(name,age)&#123;</span><br><span class="line">            Parent.call(this,name); </span><br><span class="line">            this.age &#x3D; age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function CreateObj(o)&#123;</span><br><span class="line">            function F()&#123;&#125;;</span><br><span class="line">            F.prototype &#x3D; o;</span><br><span class="line">            return new F();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Child.prototype &#x3D; new Parent(); &#x2F;&#x2F; 这里换成下面</span><br><span class="line">        function prototype(child,parent)&#123;</span><br><span class="line">            var prototype &#x3D; CreateObj(parent.prototype);</span><br><span class="line">            prototype.constructor &#x3D; child;</span><br><span class="line">            child.prototype &#x3D; prototype;</span><br><span class="line">        &#125;</span><br><span class="line">        prototype(Child,Parent);</span><br><span class="line"></span><br><span class="line">        var child1 &#x3D; new Child(&#39;xiaopao&#39;, 18);</span><br><span class="line">        console.log(child1);</span><br></pre></td></tr></table></figure>
优点:高效率体现在只调用了一次Parent构造函数<h6 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h6></li>
<li>arguments是一个类似数组的对象,对应于传递给函数的参数</li>
<li>arguments对象是所有函数中可用的局部变量,可以使用arguments对象在函数中引用函数的参数,此对象包含传递给函数的每个参数的条目:arguments[0]</li>
<li>arguments对象不是一个Array,类似于数组,但除了长度之外没有任何数组属性,但可被转换为一个真正的数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let args &#x3D; Array.prototype.slice.call(arguments); </span><br><span class="line">let args &#x3D; [].slice.call(arguments);</span><br></pre></td></tr></table></figure></li>
<li>使用Array.from()方法或者spread运算符将arguments转换成真正的数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let args &#x3D; Array.from(arguments);</span><br><span class="line">let args &#x3D; [...arguments];</span><br></pre></td></tr></table></figure></li>
<li>arguments对象仅在函数内部有效,在函数外部调用arguments对象会出现一个错误</li>
<li>arguments的typeof返回object</li>
<li>使用索引来确定各个arguments的类型 typeof arguments[0]</li>
<li><strong>属性</strong>:<br>  1.arguments.callee  //指向当前执行的函数<br>  2.arguments.caller  //指向调用当前函数的函数<br>  3.arguments.length  //指向传递给当前函数的参数数量</li>
<li>例子<br>  1.定义一个函数连接字符串,这个函数唯一正式声明了的参数是一个字符串,该参数指定一个字符作为衔接点来连接字符串<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function myConcat(separator) &#123;</span><br><span class="line">  var args &#x3D; Array.prototype.slice.call(arguments, 1);</span><br><span class="line">  return args.join(separator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
传递任意数量的参数到该函数,然后该函数会将每个参数作为一个条目来创建一个列表<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">myConcat(&quot;, &quot;, &quot;red&quot;, &quot;orange&quot;, &quot;blue&quot;);</span><br><span class="line">&#x2F;&#x2F; returns &quot;red, orange, blue&quot;</span><br><span class="line">myConcat(&quot;; &quot;, &quot;elephant&quot;, &quot;giraffe&quot;, &quot;lion&quot;, &quot;cheetah&quot;);</span><br><span class="line">&#x2F;&#x2F; returns &quot;elephant; giraffe; lion; cheetah&quot;</span><br><span class="line">myConcat(&quot;. &quot;, &quot;sage&quot;, &quot;basil&quot;, &quot;oregano&quot;, &quot;pepper&quot;, &quot;parsley&quot;);</span><br><span class="line">&#x2F;&#x2F; returns &quot;sage. basil. oregano. pepper. parsley&quot;</span><br></pre></td></tr></table></figure>
<h6 id="作用域链、闭包、作用域"><a href="#作用域链、闭包、作用域" class="headerlink" title="作用域链、闭包、作用域"></a>作用域链、闭包、作用域</h6></li>
<li>作用域:全局作用域(代码在程序的任何地方都能被访问,window对象的内置属性都拥有全局作用域)和函数作用域(在固定的代码片段才能被访问)<br><img src="https://images0.cnblogs.com/blog/138012/201409/241708372951952.png" alt="image"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">作用域的最大用处是隔离变量,不同作用域下同名变量不会有冲突,形成全局作用域的情况:</span><br><span class="line">1.最外层函数和在最外层函数外面定义的变量拥有全局作用域</span><br><span class="line">2.所有未定义直接赋值的变量自动声明为拥有全局作用域</span><br><span class="line">3.所有window对象的属性拥有全局作用域</span><br></pre></td></tr></table></figure>
作用域是分层的,内层作用域可以访问外层作用域的变量,反之则不行;块语句{},如if switch for while循环语句不像函数,不会创建一个新的作用域,在块语句中定义的变量将保留在他们已经存在的作用域中</li>
<li>作用域链:一般情况下,变量取值到创建这个变量的函数的作用中去取值,单丝如果在当前作用域中没有查到值,就会去上级作用域去查,直到查到全局作用域,这个查找的过程形成的链条叫做作用域链,内部环境可以通过作用域链访问所有外部环境,但外部环境不能访问内部环境的任何变量和函数</li>
<li>闭包:闭包拥有的特性(1.函数嵌套函数2.函数内部可以引用函数外部的参数和变量3.参数和变量不会被垃圾回收机制回收)<!-- --- -->
1.函数作为返回值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;</span><br><span class="line">			var name &#x3D; &#39;dov&#39;</span><br><span class="line">			return function()&#123;</span><br><span class="line">				return name;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		var b &#x3D; a()</span><br><span class="line">		console.log(b()) &#x2F;&#x2F;&#39;dov&#39;</span><br></pre></td></tr></table></figure>
在这段代码中,a()的返回值是一个匿名函数,这个函数在a()作用域内部,所以可以获取a()作用域下变量name的值,将这个值作为返回值赋给全局作用域下的变量b,实现了在全局变量下获取到局部变量中的变量的值;<br>经典例子:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function fn()&#123;</span><br><span class="line">			var num &#x3D; 3</span><br><span class="line">			return function()&#123;</span><br><span class="line">				var n &#x3D; 0;</span><br><span class="line">				console.log(++n)</span><br><span class="line">				console.log(++num)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		var fn1 &#x3D; fn()</span><br><span class="line">		fn1() &#x2F;&#x2F;1 4</span><br><span class="line">		fn1() &#x2F;&#x2F;1 5</span><br></pre></td></tr></table></figure>
一般情况下,在函数fn执行完后,就应该连同它里面的变量一同被销毁,但是这里匿名函数作为fn的返回值被赋值给了fn1,这时候相当于fn1 = function(){var n = 0 …},并且匿名函数内部引用着fn里面的变量num,所以变量num无法被销毁,而变量n是每次被调用时新创建的,所以每次fn1执行完后它就把属于自己的变量连同自己一起销毁,这里就产生了内存消耗的问题<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (var i &#x3D; 0;i&lt;5;i++) &#123;</span><br><span class="line">			setTimeout(function() &#123;</span><br><span class="line">				console.log(i+&#39;&#39;)</span><br><span class="line">			&#125;,100)</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
按照预期应该是依次输出12345,这里会打印5次5,这是由于js是单线程的,在执行for循环的时候定时器setTimeout()被安排到任务队列中排队等待执行,而在等待的过程中for循环已经开始执行,等到定时函数可以执行的时候,for循环已经结束,i值已为5,可将var修改为let<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (var i &#x3D; 0;i&lt;5;i++) &#123;</span><br><span class="line">			(function(i)&#123;</span><br><span class="line">				setTimeout(function() &#123;</span><br><span class="line">					console.log(i+&#39;&#39;)</span><br><span class="line">				&#125;,100)</span><br><span class="line">			&#125;(i))</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
引用闭包来保存变量i,将setTimeout放入立即执行函数中,将for循环中的循环制i作为参数传递,100毫秒后同时打印出1 2 3 4 5<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (var i &#x3D; 1;i&lt;&#x3D;5;i++) &#123;</span><br><span class="line">			(function(i)&#123;</span><br><span class="line">				setTimeout(function() &#123;</span><br><span class="line">					console.log(i+&#39;&#39;)</span><br><span class="line">				&#125;,100*i)</span><br><span class="line">			&#125;(i))</span><br><span class="line">		&#125;</span><br><span class="line">这里实现了每隔100毫秒分别依次输出数字,同时启动几个定时器,只不过执行时间不同</span><br></pre></td></tr></table></figure></li>
</ul>
<p>2.闭包作为参数传递</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var num &#x3D; 15</span><br><span class="line">		var fn1 &#x3D; function(x) &#123;</span><br><span class="line">			if(x&gt;num) &#123;</span><br><span class="line">				console.log(x)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		void function(fn2) &#123;</span><br><span class="line">			var num &#x3D; 100</span><br><span class="line">			fn2(30)</span><br><span class="line">		&#125;(fn1)</span><br><span class="line">函数fn1作为参数传入立即实行函数中,在执行到fn2(30)的时候,30作为参数传入fn1中,这时候if(x&gt;num)中的num值并不是取得立即执行函数中的num,而是取创建函数的作用域中的num,也就是全局作用域中,所以打印30</span><br></pre></td></tr></table></figure>

<h6 id="ajax的原生写法"><a href="#ajax的原生写法" class="headerlink" title="ajax的原生写法"></a>ajax的原生写法</h6><ul>
<li>ajax优点:无刷新更新数据(无需重载整个页面,按需求请求部分数据,节约带宽,减少服务器压力);异步与服务器通信</li>
<li>ajax缺点:安全问题;浏览器的收藏功能在某些情况使用不便时(用户想收藏第二页数据时),浏览器的后退功能在某些情况使用不便(用户退回第一页时)</li>
<li>原生js实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">xhr.open(&#39;请求方式GET或者POST或者其他&#39;, 请求地址url, 是否开启异步async);</span><br><span class="line">xhr.onreadystatechange &#x3D; function() &#123;</span><br><span class="line">    &#x2F;&#x2F; readyState &#x3D;&#x3D; 4说明请求已完成</span><br><span class="line">    if (xhr.readyState &#x3D;&#x3D; 4 &amp;&amp; xhr.status &#x3D;&#x3D; 200) &#123;</span><br><span class="line">        console.log(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">if (method &#x3D;&#x3D; &#39;POST&#39;) &#123;</span><br><span class="line">    &#x2F;&#x2F;给指定的HTTP请求头赋值</span><br><span class="line">    xhr.setRequestHeader(&#39;Content-type&#39;, &#39;application&#x2F;x-www-form-urlencoded&#39;);</span><br><span class="line">&#125;</span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure></li>
<li>XMLHttpRequest的属性:</li>
</ul>
<p>1.onreadystatechange:值为一个function,当readystate属性改变时调用<br>2.readyState:http请求过程中的状态值</p>
<table>
<thead>
<tr>
<th>状态值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>初始化状态,XMLHttpRequest对象已经创建或已被abort()方法重置</td>
</tr>
<tr>
<td>1</td>
<td>open()方法已调用,但是send()方法未调用,请求还没有被发送</td>
</tr>
<tr>
<td>2</td>
<td>send()方法已调用,http请求已发送到web服务器,未接收到响应</td>
</tr>
<tr>
<td>3</td>
<td>所有响应头部都已经接收到,响应体开始接受但未完成</td>
</tr>
<tr>
<td>4</td>
<td>http响应已经完全接受</td>
</tr>
</tbody></table>
<p>3.responstText:目前为止收到的响应体(不包括头部),或者如果还没有接收到数据的话,就是空字符串,如果readyState小于3,这个属性是一个空字符串,当readyState为3,这个属性返回目前已经接收的响应部分,如果readyState为4,这个属性保存了完成的响应体  </p>
<p>4.responseXML:对请求的响应,解析为XML并作为Document对象返回  </p>
<p>5.status:由服务端返回的http状态代码,当readyState小于3的时候读取这个属性会导致一个异常  </p>
<p>6.statusText:这个属性用名称而不是数字指定了请求的http的状态代码,当状态为200的时候为ok,当状态为404时为not found,当readyState小于3的时候读取这个属性会导致一个异常</p>
<ul>
<li>XMLHttpRequest的方法</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>open(method,url,async)</td>
<td>method(http请求方式),url(请求路径),async(是否异步请求,默认为true)</td>
<td>初始化一个请求,在一个已经激活的request下(已经调用open()方法的request),再次调用这个方法相当于调用了abort()</td>
</tr>
<tr>
<td>abort()</td>
<td>无</td>
<td>取消当前响应,关闭连接并且结束任何未决的网络活动,这个方法把XMLHttpRequest对象重置为readyState为0的状态,并且取消所有未决的网络活动,如果请求用了太长时间,并且响应不再必要的时候,可以调用这个方法</td>
</tr>
<tr>
<td>send(string)</td>
<td>只有post方式才传参,参数类型为字符串</td>
<td>发送HTTP请求,只有post方式才传参</td>
</tr>
<tr>
<td>setRequestHeader(header,value)</td>
<td>header(设置的请求头名称),value(对应的请求头的值)</td>
<td>向一个打开但为发送的亲戚设置或添加一个HTTP请求(设置请求头),一般post亲戚一般情况下需要设置请求头</td>
</tr>
<tr>
<td>getAllResponseHeaders()</td>
<td>无</td>
<td>把http相应头部作为未解析的字符串返回,如果readyState小于3,这个方法返回null,否则返回服务器发送的所有http响应的头部,头部作为单个的字符串返回,一行一个头部,每行用换行符’\r\n’隔开</td>
</tr>
<tr>
<td>getResponseHeader(name)</td>
<td>name(要返回的http响应头部的名称)</td>
<td>返回指定的http响应头部的值</td>
</tr>
<tr>
<td>- 封装</td>
<td></td>
<td></td>
</tr>
<tr>
<td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">const $ &#x3D; (function() &#123;</span><br><span class="line">    var name &#x3D; &#39;jquery&#39;;</span><br><span class="line">    return &#123;</span><br><span class="line">        ajax: function(&#123;</span><br><span class="line">            type,</span><br><span class="line">            url,</span><br><span class="line">            data,</span><br><span class="line">            isAsync,</span><br><span class="line">            success</span><br><span class="line">        &#125;) &#123;</span><br><span class="line">            if (!url) &#123;</span><br><span class="line">                console.error(&#39;请输入请求地址&#39;)</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 处理data对象</span><br><span class="line">            var query &#x3D; [],</span><br><span class="line">            queryData;</span><br><span class="line">            for (var key in data) &#123;</span><br><span class="line">                &#x2F;&#x2F; 默认encodeURIComponent一下</span><br><span class="line">                query.push(encodeURIComponent(key) + &#39;&#x3D;&#39; + encodeURIComponent(data[key]));</span><br><span class="line">            &#125;</span><br><span class="line">            queryData &#x3D; query.join(&#39;&amp;&#39;);</span><br><span class="line"></span><br><span class="line">            if (type &#x3D;&#x3D; &#39;GET&#39;) &#123;</span><br><span class="line">                &#x2F;&#x2F; get方式参数要跟在url上</span><br><span class="line">                url &#x3D; url + &#39;?&#39; + queryData</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 默认使用GET,默认异步</span><br><span class="line">            xhr.open(type || &#39;GET&#39;, url, isAsync || true);</span><br><span class="line">            xhr.onreadystatechange &#x3D; function() &#123;</span><br><span class="line">                if (xhr.readyState &#x3D;&#x3D; 4 &amp;&amp; xhr.status &#x3D;&#x3D; 200) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 有传入success回调就执行</span><br><span class="line">                    success &amp;&amp; success(xhr.responseText);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (type &#x3D;&#x3D; &#39;POST&#39;) &#123;</span><br><span class="line">                &#x2F;&#x2F;给指定的HTTP请求头赋值</span><br><span class="line">                xhr.setRequestHeader(&#39;Content-type&#39;, &#39;application&#x2F;x-www-form-urlencoded&#39;);</span><br><span class="line">                &#x2F;&#x2F; 数组转成字符串</span><br><span class="line">                xhr.send(queryData)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                xhr.send()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;类似jquery的使用方式</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    type: &#39;POST&#39;,</span><br><span class="line">    url: &#39;https:&#x2F;&#x2F;web-api.juejin.im&#x2F;gptzllpbev&#39;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        name: &#39;嘻嘻&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    success: function(res) &#123;</span><br><span class="line">        console.log(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></td>
<td></td>
<td></td>
</tr>
<tr>
<td>###### 对象深拷贝和浅拷贝</td>
<td></td>
<td></td>
</tr>
<tr>
<td>- js复制引用类型:变量复制引用类型值的时候,同样和基本类型值一样会把变量的值复制到新变量上,不同的是对于变量的值,它是一个指针,指向存储在堆内存中的对象</td>
<td></td>
<td></td>
</tr>
<tr>
<td>![image](<a href="https://upload-images.jianshu.io/upload_images/13835400-8fbc20585f406fae?imageMogr2/auto-orient/strip" target="_blank" rel="noopener">https://upload-images.jianshu.io/upload_images/13835400-8fbc20585f406fae?imageMogr2/auto-orient/strip</a></td>
<td>imageView2/2/w/992/format/webp)</td>
<td></td>
</tr>
<tr>
<td>- 浅拷贝:创建一个新对象,这个对象有着原始对象属性值的一份精确拷贝,如果属性是基本类型,拷贝的是基本类型的值,如果属性是引用类型,拷贝的是内存地址,所以如果其中一个对象改变了这个地址,就会影响到另一个对象</td>
<td></td>
<td></td>
</tr>
<tr>
<td>- Object.assign():接受第一个参数是拷贝的目标,剩下的参数是拷贝的源对象 Object.assign(target,…sources),仍然是一个浅拷贝,只是在根属性创建了一个新的对象,但是对于属性的值仍是对象的话依然是浅拷贝,不会拷贝对象继承的属性,不可枚举的属性,属性的数据属性/访问器属性,可以拷贝symbol类型</td>
<td></td>
<td></td>
</tr>
<tr>
<td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var target &#x3D; &#123;&#125;;</span><br><span class="line">var source &#x3D; &#123;a:1&#125;;</span><br><span class="line">Object.assign(target ,source);</span><br><span class="line">console.log(target); &#x2F;&#x2F;&#123;a:1&#125;</span><br><span class="line">source.a &#x3D; 2;</span><br><span class="line">console.log(source); &#x2F;&#x2F;&#123;a:2&#125;</span><br><span class="line">console.log(target); &#x2F;&#x2F;&#123;a:1&#125;</span><br></pre></td></tr></table></figure></td>
<td></td>
<td></td>
</tr>
<tr>
<td>- 扩展运算符 var cloneObj = {…obj},如下有同样的缺陷,对于值是对象的属性无法完全拷贝成2个不同对象,但是属性都是基本类型的值得话,使用扩展运算符更加方便</td>
<td></td>
<td></td>
</tr>
<tr>
<td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;a:1,b:&#123;c:1&#125;&#125;</span><br><span class="line">var obj2 &#x3D; &#123;...obj&#125;;</span><br><span class="line">obj.a&#x3D;2;</span><br><span class="line">console.log(obj); &#x2F;&#x2F;&#123;a:2,b:&#123;c:1&#125;&#125;</span><br><span class="line">console.log(obj2); &#x2F;&#x2F;&#123;a:1,b:&#123;c:1&#125;&#125;</span><br><span class="line"></span><br><span class="line">obj.b.c &#x3D; 2;</span><br><span class="line">console.log(obj); &#x2F;&#x2F;&#123;a:2,b:&#123;c:2&#125;&#125;</span><br><span class="line">console.log(obj2); &#x2F;&#x2F;&#123;a:1,b:&#123;c:2&#125;&#125;</span><br></pre></td></tr></table></figure></td>
<td></td>
<td></td>
</tr>
<tr>
<td>- Array.prototype.slice():返回一个新的数组对象,这个对象是一个由begin和end决定的原数组的浅拷贝,原始数组不会被改变 arr.slice(begin,end)</td>
<td></td>
<td></td>
</tr>
<tr>
<td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.slice.call(&#123;0: &quot;aaa&quot;, length: 1&#125;) &#x2F;&#x2F;[&quot;aaa&quot;]</span><br><span class="line">let arr &#x3D; [1,2,3,4]</span><br><span class="line">console.log(arr.slice() &#x3D;&#x3D;&#x3D; arr); &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure></td>
<td></td>
<td></td>
</tr>
<tr>
<td>- 深拷贝:浅拷贝只是在根属性上在堆内存中创建了一个新的对象,复制了基本类型的值,但是复杂数据类型也就是对象则是拷贝相同的地址,而深拷贝则是对于复杂数据类型在堆内存中开辟了一块内存地址用于存放复制的对象并且把原有的对象复制过来,这2个对象是相互独立的,也就是2个不同的地址</td>
<td></td>
<td></td>
</tr>
<tr>
<td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var obj1 &#x3D; &#123;</span><br><span class="line">    a: &#123;</span><br><span class="line">        b: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    c: 1</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj2.a &#x3D; &#123;&#125;</span><br><span class="line">obj2.c &#x3D; obj1.c</span><br><span class="line">obj2.a.b &#x3D; obj1.a.b;</span><br><span class="line">console.log(obj1); &#x2F;&#x2F;&#123;a:&#123;b:1&#125;,c:1&#125;;</span><br><span class="line">console.log(obj2); &#x2F;&#x2F;&#123;a:&#123;b:1&#125;,c:1&#125;;</span><br><span class="line">obj1.a.b &#x3D; 2;</span><br><span class="line">console.log(obj1); &#x2F;&#x2F;&#123;a:&#123;b:2&#125;,c:1&#125;;</span><br><span class="line">console.log(obj2); &#x2F;&#x2F;&#123;a:&#123;b:1&#125;,c:1&#125;;</span><br></pre></td></tr></table></figure></td>
<td></td>
<td></td>
</tr>
<tr>
<td>- JSON.stringify():把一个对象序列化成为一个JSON字符串,将对象的内容转换成字符串的形式再保存在磁盘上,再用JSON.parse()反序列化将JSON字符串变成一个新的对象</td>
<td></td>
<td></td>
</tr>
<tr>
<td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj1 &#x3D; &#123;</span><br><span class="line">    a:1,</span><br><span class="line">    b:[1,2,3]</span><br><span class="line">&#125;</span><br><span class="line">var str &#x3D; JSON.stringify(obj1)</span><br><span class="line">var obj2 &#x3D; JSON.parse(str)</span><br><span class="line">console.log(obj2); &#x2F;&#x2F;&#123;a:1,b:[1,2,3]&#125;</span><br><span class="line">obj1.a&#x3D;2</span><br><span class="line">obj1.b.push(4);</span><br><span class="line">console.log(obj1); &#x2F;&#x2F;&#123;a:2,b:[1,2,3,4]&#125;</span><br><span class="line">console.log(obj2); &#x2F;&#x2F;&#123;a:1,b:[1,2,3]&#125;</span><br></pre></td></tr></table></figure></td>
<td></td>
<td></td>
</tr>
<tr>
<td>拷贝的对象的值中如果有函数,undefined,symbol则经过JSON.stringify()序列化后的JSON字符串中这个键值对会消失;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>无法拷贝不可枚举的属性,无法拷贝对象的原型链</td>
<td></td>
<td></td>
</tr>
<tr>
<td>拷贝Date引用类型会变成字符串</td>
<td></td>
<td></td>
</tr>
<tr>
<td>拷贝RegExp引用类型会变成空对象</td>
<td></td>
<td></td>
</tr>
<tr>
<td>对象中含有NaN Infinity -Infinity,则序列化的结果会变成null</td>
<td></td>
<td></td>
</tr>
<tr>
<td>无法拷贝对象的循环引用(obj[key] = obj)</td>
<td></td>
<td></td>
</tr>
<tr>
<td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line">function Obj() &#123;</span><br><span class="line">    this.func &#x3D; function () &#123;</span><br><span class="line">        alert(1) </span><br><span class="line">    &#125;;</span><br><span class="line">    this.obj &#x3D; &#123;a:1&#125;;</span><br><span class="line">    this.arr &#x3D; [1,2,3];</span><br><span class="line">    this.und &#x3D; undefined;</span><br><span class="line">    this.reg &#x3D; &#x2F;123&#x2F;;</span><br><span class="line">    this.date &#x3D; new Date(0);</span><br><span class="line">    this.NaN &#x3D; NaN</span><br><span class="line">    this.infinity &#x3D; Infinity</span><br><span class="line">    this.sym &#x3D; Symbol(1)</span><br><span class="line">&#125;</span><br><span class="line">var obj1 &#x3D; new Obj();</span><br><span class="line">Object.defineProperty(obj1,&#39;innumerable&#39;,&#123;</span><br><span class="line">    enumerable:false,</span><br><span class="line">    value:&#39;innumerable&#39;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&#39;obj1&#39;,obj1);</span><br><span class="line">var str &#x3D; JSON.stringify(obj1);</span><br><span class="line">var obj2 &#x3D; JSON.parse(str);</span><br><span class="line">console.log(&#39;obj2&#39;,obj2);</span><br></pre></td></tr></table></figure></td>
<td></td>
<td></td>
</tr>
<tr>
<td>- 借用jq方法,$.extend( [deep ], target, object1 [, objectN ] ),deep表示是否深拷贝;target(object类型,目标对象,其他对象的成员属性将被附加到该对象上); object1(objectN可选,Object类型 第一个以及第N个被合并的对象)</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let a&#x3D;[0,1,[2,3],4],</span><br><span class="line">    b&#x3D;$.extend(true,[],a);</span><br><span class="line">a[0]&#x3D;1;</span><br><span class="line">a[2][0]&#x3D;1;</span><br><span class="line">console.log(a,b);</span><br><span class="line">&#96;&#96;&#96;</span><br></pre></td></tr></table></figure>


<h6 id="js-图片懒加载和预加载"><a href="#js-图片懒加载和预加载" class="headerlink" title="js 图片懒加载和预加载"></a>js 图片懒加载和预加载</h6><ul>
<li>图片预加载:网页全部加载之前,提前加载图片,当用户需要查看时可直接从本地缓存中渲染,以提供给用户更好的体验,减少等待的时间</li>
<li>图片懒加载:延迟加载图片或符合某些条件时才加载某些图片</li>
<li>两种技术的本质:两者的行为是相反的,一个是提前加载,一个是迟缓甚至不加载</li>
<li>懒加载对服务器前端有一定的缓解压力作用,预加载会增加服务器前端压力</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/qlPersonalBlog.github.io/2020/04/14/css/" rel="next" title="css">
                <i class="fa fa-chevron-left"></i> css
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/qlPersonalBlog.github.io/2020/04/15/vue/" rel="prev" title="vue">
                vue <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Qiris</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/qlPersonalBlog.github.io/archives">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-6"><a class="nav-link" href="#判断-js-类型的方式"><span class="nav-number">1.</span> <span class="nav-text">判断 js 类型的方式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ES5-和-ES6-分别几种方式声明变量"><span class="nav-number">2.</span> <span class="nav-text">ES5 和 ES6 分别几种方式声明变量</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#闭包的概念？优缺点？"><span class="nav-number">3.</span> <span class="nav-text">闭包的概念？优缺点？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#浅拷贝和深拷贝"><span class="nav-number">4.</span> <span class="nav-text">浅拷贝和深拷贝</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#数组去重的方法"><span class="nav-number">5.</span> <span class="nav-text">数组去重的方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#js的typeof返回哪些数据类型"><span class="nav-number">6.</span> <span class="nav-text">js的typeof返回哪些数据类型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#列举3中强制类型转换和2中隐式类型转换"><span class="nav-number">7.</span> <span class="nav-text">列举3中强制类型转换和2中隐式类型转换</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#split-join-的区别"><span class="nav-number">8.</span> <span class="nav-text">split() join()的区别</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#数组方法pop-push-unshift-shift"><span class="nav-number">9.</span> <span class="nav-text">数组方法pop() push() unshift() shift()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ie和标准下有哪些兼容性的写法"><span class="nav-number">10.</span> <span class="nav-text">ie和标准下有哪些兼容性的写法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ajax请求的时候-get和post方式的区别"><span class="nav-number">11.</span> <span class="nav-text">ajax请求的时候 get和post方式的区别</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#call-和apply-的作用与区别"><span class="nav-number">12.</span> <span class="nav-text">call()和apply()的作用与区别</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ajax请求时-如何解析json数据"><span class="nav-number">13.</span> <span class="nav-text">ajax请求时,如何解析json数据</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#事件委托是什么"><span class="nav-number">14.</span> <span class="nav-text">事件委托是什么</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#如何组织事件冒泡"><span class="nav-number">15.</span> <span class="nav-text">如何组织事件冒泡</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#如何阻止默认事件"><span class="nav-number">16.</span> <span class="nav-text">如何阻止默认事件</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#添加-删除-替换-插入到某个节点的方法"><span class="nav-number">17.</span> <span class="nav-text">添加 删除 替换 插入到某个节点的方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#结束jsonp的原理-以及为什么不是真正的ajax"><span class="nav-number">18.</span> <span class="nav-text">结束jsonp的原理,以及为什么不是真正的ajax</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#doucument-load-和-doucument-ready的区别"><span class="nav-number">19.</span> <span class="nav-text">doucument load 和 doucument ready的区别</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#和-不同"><span class="nav-number">20.</span> <span class="nav-text">&#x3D; &#x3D;和&#x3D;&#x3D;&#x3D;不同</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#函数声明与函数表达式的区别"><span class="nav-number">21.</span> <span class="nav-text">函数声明与函数表达式的区别</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#对作用于上下文和this的理解"><span class="nav-number">22.</span> <span class="nav-text">对作用于上下文和this的理解</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#javascript的同源策略"><span class="nav-number">23.</span> <span class="nav-text">javascript的同源策略</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#最快捷的数组求最大值"><span class="nav-number">24.</span> <span class="nav-text">最快捷的数组求最大值</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#简洁的数组去重"><span class="nav-number">25.</span> <span class="nav-text">简洁的数组去重</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#排序算法"><span class="nav-number">26.</span> <span class="nav-text">排序算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#找字符串中出现次数最多的字符"><span class="nav-number">27.</span> <span class="nav-text">找字符串中出现次数最多的字符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#js的事件流模型"><span class="nav-number">28.</span> <span class="nav-text">js的事件流模型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#判断字符串以字母开头-后面可以是数字-下划线-字母-长度为6-30"><span class="nav-number">29.</span> <span class="nav-text">判断字符串以字母开头,后面可以是数字,下划线,字母,长度为6-30</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#js的2中变量范围有什么不同"><span class="nav-number">30.</span> <span class="nav-text">js的2中变量范围有什么不同</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#原型-原型链-构造函数-实例-继承"><span class="nav-number">31.</span> <span class="nav-text">原型&#x2F;原型链&#x2F;构造函数&#x2F;实例&#x2F;继承</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#实现继承的几种方式"><span class="nav-number">32.</span> <span class="nav-text">实现继承的几种方式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#arguments对象"><span class="nav-number">33.</span> <span class="nav-text">arguments对象</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#作用域链、闭包、作用域"><span class="nav-number">34.</span> <span class="nav-text">作用域链、闭包、作用域</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ajax的原生写法"><span class="nav-number">35.</span> <span class="nav-text">ajax的原生写法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#js-图片懒加载和预加载"><span class="nav-number">36.</span> <span class="nav-text">js 图片懒加载和预加载</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Qiris</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/qlPersonalBlog.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/qlPersonalBlog.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/qlPersonalBlog.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/qlPersonalBlog.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/qlPersonalBlog.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/qlPersonalBlog.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/qlPersonalBlog.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/qlPersonalBlog.github.io/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/qlPersonalBlog.github.io/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/qlPersonalBlog.github.io/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/qlPersonalBlog.github.io/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/qlPersonalBlog.github.io/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/qlPersonalBlog.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
